## 十种排序算法

1. 冒泡排序（Bubble Sort）：
时间复杂度为 O(n^2)，稳定排序算法。

2. 选择排序（Selection Sort）：
时间复杂度为 O(n^2)，不稳定排序算法。

3. 插入排序（Insertion Sort）：
时间复杂度为 O(n^2)，稳定排序算法。

4. 希尔排序（Shell Sort）：
时间复杂度为 O(n log n) ~ O(n^2)，不稳定排序算法。

5. 归并排序（Merge Sort）：
时间复杂度为 O(n log n)，稳定排序算法。

6. 快速排序（Quick Sort）：
时间复杂度为 O(n log n)，不稳定排序算法。

7. 堆排序（Heap Sort）：
时间复杂度为 O(n log n)，不稳定排序算法。

8. 计数排序（Counting Sort）：
时间复杂度为 O(n + k)，稳定排序算法。

9. 桶排序（Bucket Sort）：
时间复杂度为 O(n + k)，稳定排序算法。

10. 基数排序（Radix Sort）：
时间复杂度为 O(d(n+k))，稳定排序算法。

其中，n 表示数据集合内元素的数量，k 表示数据集合内元素的取值范围，d 表示数字位数。

## 稳定排序和不稳定排序

稳定排序是一种排序算法，在排序过程中，如果有两个元素的值相等，那么它们在排序后的相对位置不会改变，即它们的顺序保持不变。

例如，考虑以下数组：

```
[{age: 25, name: '张三'}, {age: 20, name: '李四'}, {age: 25, name: '王五'}]
```

如果按照年龄从小到大进行排序且采用稳定排序，那么排序后的数组应该是这样的：

```
[{age: 20, name: '李四'}, {age: 25, name: '张三'}, {age: 25, name: '王五'}]
```

其中，25岁的张三和王五的顺序和排序之前保持一致，称为稳定排序；如果采用不稳定的排序算法，可能会把它们的顺序打乱。

### 冒泡排序

冒泡排序是一种简单但效率较低的排序算法，以下是其基本逻辑及Java代码实现：

1. 基本逻辑

（1）从数组的第一个元素开始，依次与相邻的元素进行比较，如果前一个元素大于后一个元素，就将它们的位置交换。

（2）接着依次比较第二个、第三个...一直到倒数第二个元素和它相邻的元素，如果有需要就进行交换。

（3）重复上述过程，一直到最后一个元素与它相邻的元素比较完毕，此时最后一个元素已经成为了整个数组中最大的元素。

（4）重复执行上述过程，每次确定一个元素的位置，一直到整个数组排序完成。

2. Java代码实现

```java
public static void bubbleSort(int[] arr) {
    if (arr == null || arr.length <= 1) {
        return;
    }
    for (int i = 0; i < arr.length - 1; ++i) {
        boolean flag = false;  // 用于标记本轮是否发生了交换
        for (int j = 0; j < arr.length - i - 1; ++j) {
            if (arr[j] > arr[j + 1]) {
                swap(arr, j, j + 1);
                flag = true;
            }
        }
        if (!flag) {
            // 如果本轮没有发生交换，则说明已经排好序，可以直接退出循环
            break;
        }
    }
}

private static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

代码中的 `bubbleSort` 方法实现了冒泡排序算法，`swap` 方法用于交换数组中两个元素的位置。在 `bubbleSort` 方法的实现中，首先针对数组进行特殊情况的处理，即如果数组为空或长度为1，则直接返回。

然后外层循环 `i` 控制排序轮数，每一轮都会确定一个元素的最终位置；内层循环 `j` 依次比较相邻的元素，如果前一个元素大于后一个元素，则交换它们的位置。

同时，我们还设置了一个 `flag` 变量来标记本轮是否发生了交换。如果本轮没有发生任何交换，说明已经排好序，可以直接退出循环。这是一种优化措施，可以减少不必要的比较和交换操作。

最后，调用 `swap` 方法实现数组元素的交换。

### 选择排序

选择排序是一种简单但效率较低的排序算法，以下是其基本逻辑及Java代码实现：

1. 基本逻辑

（1）从未排序的序列中找到最小（或最大）元素，并将其放到序列的起始位置。

（2）从剩余未排序的序列中继续寻找最小（或最大）元素，并将其放到已排序序列的末尾。

（3）重复上述过程，直到所有元素均排序完成。

2. Java代码实现

```java
public static void selectionSort(int[] arr) {
    if (arr == null || arr.length <= 1) {
        return;
    }
    for (int i = 0; i < arr.length; ++i) {
        int minIndex = i;  // 记录最小元素的索引
        for (int j = i + 1; j < arr.length; ++j) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        if (minIndex != i) {
            swap(arr, i, minIndex);
        }
    }
}

private static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

代码中的 `selectionSort` 方法实现了选择排序算法，`swap` 方法用于交换数组中两个元素的位置。在 `selectionSort` 方法的实现中，首先针对数组进行特殊情况的处理，即如果数组为空或长度为1，则直接返回。

然后外层循环 `i` 控制已排序序列的末尾位置，内层循环 `j` 在未排序序列中寻找最小元素，并记录下其索引。最后，如果已找到的最小元素不在已排序序列的起始位置，则交换它们的位置。

选择排序的时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$，与冒泡排序一样，并不是一种效率很高的排序算法，但由于其简单易懂、实现方便的特点，在某些场合下仍有一定的应用价值。

### 插入排序

插入排序是一种简单但效率较低的排序算法，以下是其基本逻辑及Java代码实现：

1. 基本逻辑

（1）将第一个元素视为已排序序列。

（2）取出下一个元素，在已排序序列中从后往前扫描，如果已排序序列中的元素大于该元素，就将已排序序列中的元素向后移动一位，直到找到一个比该元素小的位置，将该元素插入到该位置之后。

（3）重复上述过程，直到所有元素均排序完成。

2. Java代码实现

```java
public static void insertionSort(int[] arr) {
    if (arr == null || arr.length <= 1) {
        return;
    }
    for (int i = 1; i < arr.length; ++i) {
        int cur = arr[i];  // 记录当前要插入的元素
        int j = i - 1;  // 已排序序列右侧第一个元素的索引
        while (j >= 0 && arr[j] > cur) {
            arr[j + 1] = arr[j];  // 将已排序序列中大于cur的元素一次向后移动一位
            --j;
        }
        arr[j + 1] = cur;  // 插入cur到正确的位置
    }
}
```

代码中的 `insertionSort` 方法实现了插入排序算法。在 `insertionSort` 方法的实现中，首先针对数组进行特殊情况的处理，即如果数组为空或长度为1，则直接返回。

然后外层循环 `i` 控制当前要插入的元素，内层循环 `j` 从已排序序列的右侧第一个元素开始寻找正确的插入位置。一旦找到该位置，就将已排序序列中大于当前要插入元素的元素一次向后移动一位，然后将当前要插入的元素插入到正确的位置。

插入排序的时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$，与冒泡排序和选择排序一样，并不是一种效率很高的排序算法，但由于其简单易懂、实现方便的特点，在某些场合下仍有一定的应用价值。

### 希尔排序

希尔排序是基于插入排序的一种排序算法，以下是其基本逻辑及Java代码实现：

1. 基本逻辑

（1）将数组按照一定间隔分成若干个子序列，对每个子序列进行插入排序。

（2）逐渐缩小间隔，重复上述过程，直到间隔为1，即对整个数组进行插入排序。

2. Java代码实现

```java
public static void shellSort(int[] arr) {
    if (arr == null || arr.length <= 1) {
        return;
    }
    int n = arr.length;
    int gap = n / 2;  // 初始间隔为n/2
    while (gap > 0) {
        for (int i = gap; i < n; ++i) {
            int cur = arr[i];  // 记录当前要插入的元素
            int j = i - gap;  // 已排序序列右侧第一个元素的索引
            while (j >= 0 && arr[j] > cur) {
                arr[j + gap] = arr[j];  // 将已排序序列中大于cur的元素一次向后移动gap位
                j -= gap;
            }
            arr[j + gap] = cur;  // 插入cur到正确的位置
        }
        gap /= 2;  // 缩小间隔
    }
}
```

代码中的 `shellSort` 方法实现了希尔排序算法。在 `shellSort` 方法的实现中，首先针对数组进行特殊情况的处理，即如果数组为空或长度为1，则直接返回。

然后通过一个循环来控制间隔的缩小过程。初始间隔为 $n/2$，每次将间隔缩小一半，直到间隔为1。在每个间隔下，通过一个插入排序来对子序列进行排序。与普通的插入排序类似，也是记录当前要插入的元素，然后将已排序序列中大于该元素的元素一次向后移动一定的位数（不是一位），最后将该元素插入到正确的位置。

希尔排序的时间复杂度与间隔的选择有关，但理论上最坏情况下的时间复杂度可以达到 $O(n^2)$，空间复杂度为 $O(1)$。尽管其效率并不一定比其他排序算法更高，但由于其简单易懂、实现方便，且可以针对不同的数据集合采用不同间隔序列进行排序，因此在某些场合下仍有应用价值。